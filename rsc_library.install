<?php


/**
 * Implements hook_install().
 */
function rsc_library_install() {
  
  module_load_include('inc','rsc_library','rsc_library.common');
  
  /*
   * Settings for content types
   */
  rsc_library_content_type_settings();

  /*
   * Set up the role and permissions for library staff
   */

  $role_name = 'rsc library staff';

  // Try to load the role to see if it exists
  $role = user_role_load_by_name($role_name);
  if (!$role) {
    // create it, since it does not exist
    $role = new stdClass();
    $role->name = $role_name;
    user_role_save($role);
    // load the newly created role, to get the rid
    $role = user_role_load_by_name($role_name);
  }

  // Make a list of permissions, keyed by module
  $permissions = array(
    'node' => array(
      'access content overview',
      'access content',
      'view own unpublished content',
      'view revisions',
      'revert revisions',
      'delete revisions',
    ),
    'system' => array(
      'view the administration theme',
    ),
  );
  foreach (rsc_library_content_types() as $type) {
    $permissions['node'][] = "create ${type} content";
    $permissions['node'][] = "edit own ${type} content";
    $permissions['node'][] = "edit any ${type} content";
    $permissions['node'][] = "delete own ${type} content";
    $permissions['node'][] = "delete any ${type} content";
  }

  // Assign the permissions to library staff
  _rsc_library_grant_permissions($role->rid, $permissions);
  
}


/**
 * Implements hook_uninstall().
 */
function rsc_library_uninstall() {
  // TODO: remove variables
}


/**
 * Taken from: http://drupal.stackexchange.com/a/126042/8452
 * Custom user_role_grant_permissions function
 * does the same thing as user_role_grant_permissions
 * but it can run at install time
 * @see user_role_grant_permissions
 * @param int $rid
 * @param array $permissions
 */
function _rsc_library_grant_permissions($rid, array $permissions = array()) {
  // this line doesn't work on install / enable hooks
  // $modules = user_permission_get_modules();
  // Grant new permissions for the role.
  foreach ($permissions as $module => $permission_list) {
    foreach ($permission_list as $name) {
      db_merge('role_permission')
        ->key(array(
          'rid' => $rid,
          'permission' => $name,
        ))
        ->fields(array(
          'module' => $module,
        ))
        ->execute();
    }
  }

  // Clear the user access cache.
  drupal_static_reset('user_access');
  drupal_static_reset('user_role_permissions');
}


/**
 * Implementations of https://api.drupal.org/api/drupal/modules!system!system.api.php/function/hook_update_N/7.x
 *
 * Never renumber update functions.
 *
 * The $sandbox parameter should be used when a multipass update is needed, in circumstances where running the whole update at once could cause PHP to timeout. Each pass is run in a way that avoids PHP timeouts, provided each pass remains under the timeout limit. To signify that an update requires at least one more pass, set $sandbox['#finished'] to a number less than 1 (you need to do this each pass). The value of $sandbox['#finished'] will be unset between passes but all other data in $sandbox will be preserved. The system will stop iterating this update when $sandbox['#finished'] is left unset or set to a number higher than 1. It is recommended that $sandbox['#finished'] is initially set to 0, and then updated each pass to a number between 0 and 1 that represents the overall % completed for this update, finishing with 1.
 *
 * Optionally, update hooks may return a translated string that will be displayed to the user after the update has completed. If no message is returned, no message will be presented to the user.
 */


/**
 * Delete all nodes of type "rsc_library_audio"
 */
function rsc_library_update_7200() {

  $bundle = "rsc_library_audio";

  // Get all relevant nids
  $query = new EntityFieldQuery();
  $query
    ->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', $bundle)
    ->addMetaData('account', user_load(1));
  $result = $query->execute();

  // delete the nodes
  $nids = array();
  if (!empty($result['node'])) {
    $nids = array_keys($result['node']);
    node_delete_multiple($nids);
  }

  return t("Deleted @n nodes of type `@type`.", array(
    '@n'    => count($nids),
    '@type' => $bundle,
  ));

}


/**
 * Delete the "rsc_library_audio" content type
 */
function rsc_library_update_7201() {

  $bundle = "rsc_library_audio";

  // delete the content type
  node_type_delete($bundle);
  variable_del('node_preview_' . $bundle);

  // rebuild content types and menus
  node_types_rebuild();
  variable_set('menu_rebuild_needed', TRUE);

  return t("Deleted content type `@type`.", array(
    '@type' => $bundle,
  ));

}

